---
title: Introduction to Local Outlier Factor with R
author: Muhamad Risman
github: https://github.com/muhrisman
date: '2021-10-14'
slug: Local-Outlier-Factor-With-R
categories:
  - R
tags:
  - Unsupervised Machine Learning
  - Outlier Detection
  - Machine Learning
  - Anomaly Detection
description: ''
featured: ''
featuredalt: ''
featuredpath: ''
linktitle: ''
type: post
---

<script src="Local Outlier Factor revised algo_files/header-attrs/header-attrs.js"></script>
<script src="Local Outlier Factor revised algo_files/htmlwidgets/htmlwidgets.js"></script>
<script src="Local Outlier Factor revised algo_files/plotly-binding/plotly.js"></script>
<script src="Local Outlier Factor revised algo_files/typedarray/typedarray.min.js"></script>
<script src="Local Outlier Factor revised algo_files/jquery/jquery.min.js"></script>
<link href="Local Outlier Factor revised algo_files/crosstalk/css/crosstalk.css" rel="stylesheet" />
<script src="Local Outlier Factor revised algo_files/crosstalk/js/crosstalk.min.js"></script>
<link href="Local Outlier Factor revised algo_files/plotly-htmlwidgets-css/plotly-htmlwidgets.css" rel="stylesheet" />
<script src="Local Outlier Factor revised algo_files/plotly-main/plotly-latest.min.js"></script>
<script src="Local Outlier Factor revised algo_files/proj4js/proj4.js"></script>
<link href="Local Outlier Factor revised algo_files/highcharts/css/motion.css" rel="stylesheet" />
<script src="Local Outlier Factor revised algo_files/highcharts/highcharts.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/highcharts-3d.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/highcharts-more.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/stock.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/map.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/annotations.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/data.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/drilldown.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/item-series.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/offline-exporting.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/overlapping-datalabels.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/exporting.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/export-data.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/funnel.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/heatmap.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/treemap.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/sankey.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/dependency-wheel.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/organization.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/solid-gauge.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/streamgraph.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/sunburst.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/vector.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/wordcloud.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/xrange.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/tilemap.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/venn.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/gantt.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/timeline.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/parallel-coordinates.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/bullet.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/coloraxis.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/dumbbell.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/lollipop.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/series-label.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/plugins/motion.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/custom/reset.js"></script>
<script src="Local Outlier Factor revised algo_files/highcharts/modules/boost.js"></script>
<script src="Local Outlier Factor revised algo_files/highchart-binding/highchart.js"></script>


<style>
body{
text-align: justify}
</style>
<div id="overview" class="section level1">
<h1>Overview</h1>
<p>Local Outlier Factor (LOF) is an unsupervised machine learning algorithm to detect outlier observations in a multivariate dataset. LOF implementation can be applied to various conditions, such as seeing unusual points in a dataset. Furthermore, the algorithm can be used to detect anomaly conditions. Detecting anomaly conditions is crucial to prevent unwanted conditions further. The application of anomaly detection can be used in various industries such as e-commerce or the banking industry. Preventing anomalies or unusual situations from getting bigger will help a company preventing financial loss. Here, we will learn about the Local Outlier Factor algorithm, the basics behind this algorithm, and this algorithm works to detect unusual observations.</p>
</div>
<div id="what-is-outlier" class="section level1">
<h1>What is Outlier?</h1>
<p>Outlier is observations that do not follow the same pattern compared to the rest of the data. For example, a boy with a 100 score for his math test while his friends mainly got around 30 is the outlier. The score achieved by the boy is considered an outlier since the pattern of the data here is 30. A-10-years old girl with an IQ of 170 while his classmates’ IQ is around 100 is also an outlier since most of the information in that situation tells us that the “normal” number is 100.</p>
<p>There are two types of an outlier, point outlier and collective outlier. Point outlier is a single data point that is unusual compared to the rest of the data, while collective outlier is more than a 1 point outlier than the rest of the data. Instances of point outlier have been introduced earlier, and it can be visualized with a graphical summary, the boxplot.</p>
<p>For example, there are 101 students attending math tests with the following result.</p>
<pre class="r"><code>math_test &lt;- c(rnorm(100, mean=30, sd=4),100)

boxplot(math_test,
main = &quot;Math Test Score&quot;,
col = &quot;orange&quot;,
border = &quot;brown&quot;,
horizontal = TRUE,
notch = TRUE
)</code></pre>
<p><img src="/blog/Local%20Outlier%20Factor%20revised%20algo_files/figure-html/unnamed-chunk-1-1.png" width="672" /></p>
<p>The student mostly got 30 for their marks, while there was one student who stunningly got 100.</p>
<p>An example of a collective outlier can be visualized as follow:</p>
<pre class="r"><code>math_test2 &lt;- c(rnorm(100, mean=30, sd=4),90,80,93,100)

boxplot(math_test2,
main = &quot;Math Test Score&quot;,
col = &quot;orange&quot;,
border = &quot;brown&quot;,
horizontal = TRUE,
notch = TRUE
)</code></pre>
<p><img src="/blog/Local%20Outlier%20Factor%20revised%20algo_files/figure-html/unnamed-chunk-2-1.png" width="672" /></p>
<p>Four students achieved stunning scores compared to their classmates. The four students here was considered a collective outlier. The example of a collective outlier can be found in many datasets since the most dataset is contributed with many observations.</p>
</div>
<div id="formal-way-to-test-outlier" class="section level1">
<h1>Formal Way To Test Outlier</h1>
<p>Visualization is a great tool to see outlier points. Besides using visualization, we can also use statistical procedures to validate if a data point is an outlier or not. One Test that can handle is Grubbs’ Test. Grubbs’ Test will see the most significant or most minor point in the data by assuming the data are typically distributed. When using Grubb’s Test, the user needs to check the distribution of the data. One common way to see the distribution of the data is using the histogram. A typical normal distributed histogram can be seen like this.</p>
<pre class="r"><code>data_example &lt;- rnorm(10000, mean= 50, sd = 15)

hist(data_example)</code></pre>
<p><img src="/blog/Local%20Outlier%20Factor%20revised%20algo_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
<p>With the example of math score above, we can do Grubbs’ Test from the <code>outlier</code> package as follow:</p>
<pre class="r"><code>library(outliers)
grubbs.test(math_test)</code></pre>
<pre><code>## 
##  Grubbs test for one outlier
## 
## data:  math_test
## G = 8.84339, U = 0.21012, p-value &lt; 2.2e-16
## alternative hypothesis: highest value 100 is an outlier</code></pre>
<p>The threshold for p-value is 0.05, and if the p-value is below 0.05, the point is considered an outlier. Grubbs’s Test will produce the hypothesis for either the highest or lowest value in the dataset. Grubbs’s Test indicates that the highest value is an anomaly with the p-value below 0.05. We can also see which row is an outlier by specifying the max or the min of the data; here, we will use max.</p>
<pre class="r"><code>which.max(math_test)</code></pre>
<pre><code>## [1] 101</code></pre>
<pre class="r"><code>math_test[101]</code></pre>
<pre><code>## [1] 100</code></pre>
<p>Row number 101 is the student with a score of 100, the student that got a far better result than the rest of his classmates.</p>
</div>
<div id="local-outlier-factor-algorithm" class="section level1">
<h1>Local Outlier Factor Algorithm</h1>
<p>Local Outlier Factor or often abbreviated as LOF, is an outlier detection algorithm by doing density-based scoring. The algorithm is similar to k-Nearest Neighbour (KNN) algorithm, while the difference is that the user will try to find observations that share similar characteristics. The output of KNN can be seen with many points close together. In LOF, the user will try to find observations that are not alike. To understand the basic algorithm of LOF, we need to evaluate some fundamental theories as follow:</p>
<div id="k-nearest-neighbour-distance" class="section level2">
<h2>K-Nearest Neighbour Distance</h2>
<p>K-Nearest Neighbour (KNN) is a classification algorithm with k nearest observations. The KNN has some algorithm before deciding which class an observation will be classified into. K-distance is the distance between an observation to its k nearest observations taking its mean value.</p>
<center>
<img src="/img/lof/knn.png" />
</center>
<p>`</p>
<p>In the example plot above, the initial observation is circled by the three nearest observations. The number 3 here is the element of k.</p>
<p>Suppose we have four observations with the following points.</p>
<pre class="r"><code>library(ggplot2)
library(hrbrthemes)

name &lt;- as.factor(c(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Cucumber&quot;, &quot;Durian&quot;))
x &lt;- c(0, 1, 1, 0)
y &lt;- c(0, 0, 1, 3)

df &lt;- data.frame(name, x, y)

ggplot(df, aes(x=x, y=y, color=name)) + 
    geom_point(size=6) +
   xlim(-4, 4) +
  ylim(-4, 4) +
    theme_ipsum()</code></pre>
<p><img src="/blog/Local%20Outlier%20Factor%20revised%20algo_files/figure-html/unnamed-chunk-7-1.png" width="672" /></p>
<p>There is one point represented by Durian that hints at us as an outlier since it is far from the rest of the data. Since we are dealing with multivariate, we can not use Grubbs’ test to assess outlier of this dataset. Hence, we can use the Local Outlier Factor to detect which observation is considered an outlier.</p>
<p>We will calculate the distance between those observations with <code>get.knn</code> from library <code>FNN</code>. The non-numeric column should be dropped since it is not representing numerical value to calculate the distance. We also use k=2 to see the two nearest observations from a point.</p>
<pre class="r"><code>library(FNN)
library(tidyverse)

knn_df &lt;- get.knn(data = df %&gt;% select(-name), k = 2)

head(knn_df$nn.dist)</code></pre>
<pre><code>##          [,1]     [,2]
## [1,] 1.000000 1.414214
## [2,] 1.000000 1.000000
## [3,] 1.000000 1.414214
## [4,] 2.236068 3.000000</code></pre>
<p>The output produced by the code above is the distance matrice from each observation. The first column is the distance between the first observation and its closest neighbour, while the second column is the distance between the first observation and the second closest neighbour. Since the k = 2, the output matrice will consist of two columns, and the distance calculation is Euclidean distances.</p>
<p>To get the KNN distance score, we will average each observation based on its distance score to the k closest neighbour.</p>
<pre class="r"><code>df_score &lt;- rowMeans(knn_df$nn.dist)

df_score</code></pre>
<pre><code>## [1] 1.207107 1.000000 1.207107 2.618034</code></pre>
<p>From the distance above, we can see that the point with the most significant distance score can be classified as an outlier.</p>
<pre class="r"><code>which.max(df_score)</code></pre>
<pre><code>## [1] 4</code></pre>
<p>The code shows that the fourth observation, Durian, is a hint as an outlier point.</p>
<p>We can also visualize the distance score for those observations for a more straightforward interpretation.</p>
<pre class="r"><code>df$distance &lt;- df_score</code></pre>
<pre class="r"><code>library(plotly)
a &lt;- ggplot(df, aes(x=x, y=y, color=name)) + 
    geom_point(aes(size=distance)) +
     xlim(-1, 2) +
  ylim(-1, 4) +
    theme_ipsum()

ggplotly(a)</code></pre>
<div id="htmlwidget-1" style="width:672px;height:480px;" class="plotly html-widget"></div>
<script type="application/json" data-for="htmlwidget-1">{"x":{"data":[{"x":[0],"y":[0],"text":"x: 0<br />y: 0<br />name: Apple<br />distance: 1.207107","type":"scatter","mode":"markers","marker":{"autocolorscale":false,"color":"rgba(248,118,109,1)","opacity":1,"size":10.5405263789183,"symbol":"circle","line":{"width":1.88976377952756,"color":"rgba(248,118,109,1)"}},"hoveron":"points","name":"Apple","legendgroup":"Apple","showlegend":true,"xaxis":"x","yaxis":"y","hoverinfo":"text","frame":null},{"x":[1],"y":[0],"text":"x: 1<br />y: 0<br />name: Banana<br />distance: 1.000000","type":"scatter","mode":"markers","marker":{"autocolorscale":false,"color":"rgba(124,174,0,1)","opacity":1,"size":3.77952755905512,"symbol":"circle","line":{"width":1.88976377952756,"color":"rgba(124,174,0,1)"}},"hoveron":"points","name":"Banana","legendgroup":"Banana","showlegend":true,"xaxis":"x","yaxis":"y","hoverinfo":"text","frame":null},{"x":[1],"y":[1],"text":"x: 1<br />y: 1<br />name: Cucumber<br />distance: 1.207107","type":"scatter","mode":"markers","marker":{"autocolorscale":false,"color":"rgba(0,191,196,1)","opacity":1,"size":10.5405263789183,"symbol":"circle","line":{"width":1.88976377952756,"color":"rgba(0,191,196,1)"}},"hoveron":"points","name":"Cucumber","legendgroup":"Cucumber","showlegend":true,"xaxis":"x","yaxis":"y","hoverinfo":"text","frame":null},{"x":[0],"y":[3],"text":"x: 0<br />y: 3<br />name: Durian<br />distance: 2.618034","type":"scatter","mode":"markers","marker":{"autocolorscale":false,"color":"rgba(199,124,255,1)","opacity":1,"size":22.6771653543307,"symbol":"circle","line":{"width":1.88976377952756,"color":"rgba(199,124,255,1)"}},"hoveron":"points","name":"Durian","legendgroup":"Durian","showlegend":true,"xaxis":"x","yaxis":"y","hoverinfo":"text","frame":null}],"layout":{"margin":{"t":71.7907845579078,"r":39.8505603985056,"b":86.8410128684101,"l":70.9007887090079},"font":{"color":"rgba(0,0,0,1)","family":"Arial Narrow","size":15.2760481527605},"xaxis":{"domain":[0,1],"automargin":true,"type":"linear","autorange":false,"range":[-1.15,2.15],"tickmode":"array","ticktext":["-1","0","1","2"],"tickvals":[-1,0,1,2],"categoryorder":"array","categoryarray":["-1","0","1","2"],"nticks":null,"ticks":"","tickcolor":null,"ticklen":3.81901203819012,"tickwidth":0,"showticklabels":true,"tickfont":{"color":"rgba(77,77,77,1)","family":"Arial Narrow","size":15.2760481527605},"tickangle":-0,"showline":false,"linecolor":null,"linewidth":0,"showgrid":true,"gridcolor":"rgba(204,204,204,1)","gridwidth":0.265670402656704,"zeroline":false,"anchor":"y","title":{"text":"x","font":{"color":"rgba(0,0,0,1)","family":"Arial Narrow","size":11.9551681195517}},"hoverformat":".2f"},"yaxis":{"domain":[0,1],"automargin":true,"type":"linear","autorange":false,"range":[-1.25,4.25],"tickmode":"array","ticktext":["-1","0","1","2","3","4"],"tickvals":[-1,0,1,2,3,4],"categoryorder":"array","categoryarray":["-1","0","1","2","3","4"],"nticks":null,"ticks":"","tickcolor":null,"ticklen":3.81901203819012,"tickwidth":0,"showticklabels":true,"tickfont":{"color":"rgba(77,77,77,1)","family":"Arial Narrow","size":15.2760481527605},"tickangle":-0,"showline":false,"linecolor":null,"linewidth":0,"showgrid":true,"gridcolor":"rgba(204,204,204,1)","gridwidth":0.265670402656704,"zeroline":false,"anchor":"x","title":{"text":"y","font":{"color":"rgba(0,0,0,1)","family":"Arial Narrow","size":11.9551681195517}},"hoverformat":".2f"},"shapes":[{"type":"rect","fillcolor":null,"line":{"color":null,"width":0,"linetype":[]},"yref":"paper","xref":"paper","x0":0,"x1":1,"y0":0,"y1":1}],"showlegend":true,"legend":{"bgcolor":null,"bordercolor":null,"borderwidth":0,"font":{"color":"rgba(0,0,0,1)","family":"Arial Narrow","size":12.2208385222084},"y":0.932086614173228},"annotations":[{"text":"name<br />distance","x":1.02,"y":1,"showarrow":false,"ax":0,"ay":0,"font":{"color":"rgba(0,0,0,1)","family":"Arial Narrow","size":15.2760481527605},"xref":"paper","yref":"paper","textangle":-0,"xanchor":"left","yanchor":"bottom","legendTitle":true}],"hovermode":"closest","barmode":"relative"},"config":{"doubleClick":"reset","showSendToCloud":false},"source":"A","attrs":{"396c4b794197":{"x":{},"y":{},"colour":{},"size":{},"type":"scatter"}},"cur_data":"396c4b794197","visdat":{"396c4b794197":["function (y) ","x"]},"highlight":{"on":"plotly_click","persistent":false,"dynamic":false,"selectize":false,"opacityDim":0.2,"selected":{"opacity":1},"debounce":0},"shinyEvents":["plotly_hover","plotly_click","plotly_selected","plotly_relayout","plotly_brushed","plotly_brushing","plotly_clickannotation","plotly_doubleclick","plotly_deselect","plotly_afterplot","plotly_sunburstclick"],"base_url":"https://plot.ly"},"evals":[],"jsHooks":[]}</script>
<p>The size of the point is based on the distance score, and we can see above that the Durian has more bold bullets than the rest of the observations.</p>
</div>
<div id="local-outlier-factor" class="section level2">
<h2>Local Outlier Factor</h2>
<p>Lof will calculate the local density of a point compared to the local density of its k neighbour. Suppose we have an example in the following picture.</p>
<center>
<img src="/img/lof/lof.png" />
</center>
<p>`</p>
<p>In the picture above, we can see that point o1 is an outlier since the distance of the point is much larger than any of the nearest points. The question is, how we suppose to label o2? With the local outlier factor algorithm, we can calculate the score of o2 and see if it is an outlier or not. The local outlier factor will produce a score with the following interpretation:</p>
<ol style="list-style-type: decimal">
<li>If LOF &gt; 1, it is likely to be an outlier point</li>
<li>If LF &lt; 1, it is likely to be not an outlier point</li>
</ol>
<p>If the point is less dense than the high-density area in C2, it is more likely to be an outlier. The more isolated point compared to its high-density neighbour, the more likely an observation is categorized as an outlier.</p>
<center>
<img src="/img/lof/lof2.JPG" />
</center>
<p>`</p>
<p>Another example is o1, and o2 can be considered an outlier, and the terms for this outlier are local. o3 is the global outlier, while o4 is not an outlier since the neighbourhood surrounding the point is not as dense as the density near o1, o2 or o3.</p>
</div>
<div id="local-outlier-factor-score-from-scratch" class="section level2">
<h2>Local Outlier Factor Score From Scratch</h2>
<p>Before we go with the function, we will try to calculate the local outlier factor score manually using the data above.</p>
<div id="find-the-distance-for-all-points" class="section level3">
<h3>Find The Distance For All Points</h3>
<p>Using the get.knn function, we can calculate the distance between a pair of points for all observations. Since the data consist of 4 observations, we will use k=3 to calculate all possible neighbours.</p>
<pre class="r"><code>example_distance &lt;- get.knn(data = df %&gt;% select(-name), k = 3)

example_distance</code></pre>
<pre><code>## $nn.index
##      [,1] [,2] [,3]
## [1,]    2    3    4
## [2,]    1    3    4
## [3,]    2    1    4
## [4,]    3    1    2
## 
## $nn.dist
##          [,1]     [,2]     [,3]
## [1,] 1.021221 1.414214 3.315225
## [2,] 1.021221 1.021221 3.552187
## [3,] 1.021221 1.414214 2.643996
## [4,] 2.643996 3.315225 3.552187</code></pre>
<p>The output above produce two results, the $nn.index provides the information about the k-nearest point of the data. For example, in the first line representing the first observation, the first nearest point is observation number 2, the second nearest point is observation number 3, and the third nearest point is observation number 4.</p>
<p>The second result produces distance for all observations to its nearest neighbour using Euclidean Distance. For example, in the second observation, the distance between the second and the third observation is 1, while the distance between the second and the fourth observation is 3.162278.</p>
</div>
<div id="find-the-distance-for-its-kth-nearest-neighbours" class="section level3">
<h3>Find The Distance For Its Kth-Nearest Neighbours</h3>
<p>Next, we need to calculate the distance for each point to the Kth nearest neighbour. Here, since we use k=2, we need to find the distance to its second nearest point. We can see again the $nn.index result above.</p>
<p>The second nearest point of Apple is Cucumber, and the distance between those points is 1.</p>
<pre class="r"><code>apple_kth_distance &lt;- 1

apple_kth_distance</code></pre>
<pre><code>## [1] 1</code></pre>
<p>The second nearest point of Banana is Cucumber. From the result of $nn.dist, we can see that the distance between Apple and Cucumber is the same. We can use either distance.</p>
<pre class="r"><code>banana_kth_distance &lt;- 1

banana_kth_distance</code></pre>
<pre><code>## [1] 1</code></pre>
<p>The second nearest point of Cucumber is Apple.</p>
<pre class="r"><code>cucumber_kth_distance &lt;- 1.414214

cucumber_kth_distance</code></pre>
<pre><code>## [1] 1.414214</code></pre>
<p>The second nearest point of Durian is Cucumber.</p>
<pre class="r"><code>durian_kth_distance &lt;- 3.000000

durian_kth_distance</code></pre>
<pre><code>## [1] 3</code></pre>
</div>
<div id="find-local-reachability-density-lrd" class="section level3">
<h3>Find Local Reachability Density (LRD)</h3>
<p>Local reachability density is the distance at which point can be found by its neighbours. The calculation will be represented by the number of parameter k divided by the reachability distance of all k nearest neighbours. Reachability distance is the maximum distance between the point to its nearest neighbour and its nearest neighbour to its kth nearest neighbour. To see it clearly, we can calculate the reachability distance for the point of A, Apple.</p>
<p>All nearest points of Apple are Banana and Cucumber. Then, we need to find reachability distance for both Banana and Cucumber.</p>
<p>The distance between Banana to Apple is 1, while Banana itself has a kth nearest neighbour. The kth or the second nearest neighbour of Banana is Cucumber, and the distance between Banana and Cucumber is 1. Hence we can calculate the maximum value from those distances.</p>
<pre class="r"><code>rd_ab &lt;- max(1,1)

rd_ab</code></pre>
<pre><code>## [1] 1</code></pre>
<p>Next, we can calculate the reachability distance for Cucumber. The distance between Cucumber to Apple is 1.414214. Cucumber’s second nearest point is Apple, and the distance is 1.414214.</p>
<pre class="r"><code>rd_ac &lt;- max(1.414214, 1.414214)

rd_ac</code></pre>
<pre><code>## [1] 1.414214</code></pre>
<p>Next, we can find the local rechability density of Apple. We have known that k = 2.</p>
<pre class="r"><code>k = 2

lrda &lt;- k/ (rd_ab + rd_ac)

lrda</code></pre>
<pre><code>## [1] 0.828427</code></pre>
<p>We can also calculate all local rechabilty distance for each observations.</p>
<p>Here is the calculation for Banana.</p>
<pre class="r"><code>rd_ba &lt;- max(1, 1.414214)
rd_bc &lt;- max(1, 1.414214)

lrdb &lt;- k/(rd_ba + rd_bc)

lrdb</code></pre>
<pre><code>## [1] 0.7071066</code></pre>
<p>Here is the calculation for Cucumber</p>
<pre class="r"><code>rd_cb &lt;- max(1, 1)
rd_ca &lt;- max(1.414214, 1.414214)

lrdc &lt;- k/(rd_cb + rd_ca)

lrdc</code></pre>
<pre><code>## [1] 0.828427</code></pre>
<p>And here is the calculation for Durian</p>
<pre class="r"><code>rd_dc &lt;- max(2.236068, 1.414214)
rd_da &lt;- max(3.000000,1.414214)

lrdd &lt;- k/(rd_dc + rd_da)

lrdd</code></pre>
<pre><code>## [1] 0.381966</code></pre>
</div>
<div id="find-local-outlier-factor-score" class="section level3">
<h3>Find Local Outlier Factor Score</h3>
<p>The final score of lof will be the sum of all local reachability distances multiplied by all reachability distances. The score is then divided by the multiplication of the number of k parameters for each nearest neighbours.</p>
<p>To calculate the local outlier factor score for Apple, the calculation will be as follow.</p>
<pre class="r"><code>lof_apple &lt;- ((lrdb + lrdc) * (rd_ab + rd_ac))/ (k * k)

lof_apple</code></pre>
<pre><code>## [1] 0.9267766</code></pre>
<p>We can also calculate the local outlier factor score for each observations.</p>
<p>Lof for Banana</p>
<pre class="r"><code>lof_banana &lt;- ((lrda + lrdc) * (rd_ba + rd_bc))/ (k * k)

lof_banana</code></pre>
<pre><code>## [1] 1.171573</code></pre>
<p>Lof for Cucumber</p>
<pre class="r"><code>lof_cucumber &lt;- ((lrda + lrdb) * (rd_ca + rd_cb))/ (k * k)

lof_cucumber</code></pre>
<pre><code>## [1] 0.9267766</code></pre>
<p>Lof for Durian</p>
<pre class="r"><code>lof_durian &lt;- ((lrda + lrdc) * (rd_da + rd_dc))/ (k * k)

lof_durian</code></pre>
<pre><code>## [1] 2.16885</code></pre>
<p>In reality, we cannot always calculate the lof score manually since we often deal with many points. To calculate the result above, we can use the lof function from the package of dbscan. Remember that the iteration will be counted from numerical value, then we need to drop the categorical variable first.</p>
<pre class="r"><code>library(dbscan)

exampe_lof &lt;- lof(df %&gt;% select(-name), k = 2)

exampe_lof</code></pre>
<pre><code>## [1] 0.9305282 1.1613642 0.9305282 2.4468815</code></pre>
<pre class="r"><code>df$lof &lt;- exampe_lof

b &lt;- ggplot(df, aes(x=x, y=y, color=name)) + 
    geom_point(aes(size=lof)) +
     xlim(-1, 2) +
  ylim(-1, 4) +
    theme_ipsum()

ggplotly(b)</code></pre>
<div id="htmlwidget-2" style="width:672px;height:480px;" class="plotly html-widget"></div>
<script type="application/json" data-for="htmlwidget-2">{"x":{"data":[{"x":[0],"y":[0],"text":"x: 0<br />y: 0<br />name: Apple<br />lof: 0.9305282","type":"scatter","mode":"markers","marker":{"autocolorscale":false,"color":"rgba(248,118,109,1)","opacity":1,"size":3.77952755905512,"symbol":"circle","line":{"width":1.88976377952756,"color":"rgba(248,118,109,1)"}},"hoveron":"points","name":"Apple","legendgroup":"Apple","showlegend":true,"xaxis":"x","yaxis":"y","hoverinfo":"text","frame":null},{"x":[1],"y":[0],"text":"x: 1<br />y: 0<br />name: Banana<br />lof: 1.1613642","type":"scatter","mode":"markers","marker":{"autocolorscale":false,"color":"rgba(124,174,0,1)","opacity":1,"size":11.1527810426934,"symbol":"circle","line":{"width":1.88976377952756,"color":"rgba(124,174,0,1)"}},"hoveron":"points","name":"Banana","legendgroup":"Banana","showlegend":true,"xaxis":"x","yaxis":"y","hoverinfo":"text","frame":null},{"x":[1],"y":[1],"text":"x: 1<br />y: 1<br />name: Cucumber<br />lof: 0.9305282","type":"scatter","mode":"markers","marker":{"autocolorscale":false,"color":"rgba(0,191,196,1)","opacity":1,"size":3.77952755905512,"symbol":"circle","line":{"width":1.88976377952756,"color":"rgba(0,191,196,1)"}},"hoveron":"points","name":"Cucumber","legendgroup":"Cucumber","showlegend":true,"xaxis":"x","yaxis":"y","hoverinfo":"text","frame":null},{"x":[0],"y":[3],"text":"x: 0<br />y: 3<br />name: Durian<br />lof: 2.4468815","type":"scatter","mode":"markers","marker":{"autocolorscale":false,"color":"rgba(199,124,255,1)","opacity":1,"size":22.6771653543307,"symbol":"circle","line":{"width":1.88976377952756,"color":"rgba(199,124,255,1)"}},"hoveron":"points","name":"Durian","legendgroup":"Durian","showlegend":true,"xaxis":"x","yaxis":"y","hoverinfo":"text","frame":null}],"layout":{"margin":{"t":71.7907845579078,"r":39.8505603985056,"b":86.8410128684101,"l":70.9007887090079},"font":{"color":"rgba(0,0,0,1)","family":"Arial Narrow","size":15.2760481527605},"xaxis":{"domain":[0,1],"automargin":true,"type":"linear","autorange":false,"range":[-1.15,2.15],"tickmode":"array","ticktext":["-1","0","1","2"],"tickvals":[-1,0,1,2],"categoryorder":"array","categoryarray":["-1","0","1","2"],"nticks":null,"ticks":"","tickcolor":null,"ticklen":3.81901203819012,"tickwidth":0,"showticklabels":true,"tickfont":{"color":"rgba(77,77,77,1)","family":"Arial Narrow","size":15.2760481527605},"tickangle":-0,"showline":false,"linecolor":null,"linewidth":0,"showgrid":true,"gridcolor":"rgba(204,204,204,1)","gridwidth":0.265670402656704,"zeroline":false,"anchor":"y","title":{"text":"x","font":{"color":"rgba(0,0,0,1)","family":"Arial Narrow","size":11.9551681195517}},"hoverformat":".2f"},"yaxis":{"domain":[0,1],"automargin":true,"type":"linear","autorange":false,"range":[-1.25,4.25],"tickmode":"array","ticktext":["-1","0","1","2","3","4"],"tickvals":[-1,0,1,2,3,4],"categoryorder":"array","categoryarray":["-1","0","1","2","3","4"],"nticks":null,"ticks":"","tickcolor":null,"ticklen":3.81901203819012,"tickwidth":0,"showticklabels":true,"tickfont":{"color":"rgba(77,77,77,1)","family":"Arial Narrow","size":15.2760481527605},"tickangle":-0,"showline":false,"linecolor":null,"linewidth":0,"showgrid":true,"gridcolor":"rgba(204,204,204,1)","gridwidth":0.265670402656704,"zeroline":false,"anchor":"x","title":{"text":"y","font":{"color":"rgba(0,0,0,1)","family":"Arial Narrow","size":11.9551681195517}},"hoverformat":".2f"},"shapes":[{"type":"rect","fillcolor":null,"line":{"color":null,"width":0,"linetype":[]},"yref":"paper","xref":"paper","x0":0,"x1":1,"y0":0,"y1":1}],"showlegend":true,"legend":{"bgcolor":null,"bordercolor":null,"borderwidth":0,"font":{"color":"rgba(0,0,0,1)","family":"Arial Narrow","size":12.2208385222084},"y":0.932086614173228},"annotations":[{"text":"lof<br />name","x":1.02,"y":1,"showarrow":false,"ax":0,"ay":0,"font":{"color":"rgba(0,0,0,1)","family":"Arial Narrow","size":15.2760481527605},"xref":"paper","yref":"paper","textangle":-0,"xanchor":"left","yanchor":"bottom","legendTitle":true}],"hovermode":"closest","barmode":"relative"},"config":{"doubleClick":"reset","showSendToCloud":false},"source":"A","attrs":{"396c5ea745e2":{"x":{},"y":{},"colour":{},"size":{},"type":"scatter"}},"cur_data":"396c5ea745e2","visdat":{"396c5ea745e2":["function (y) ","x"]},"highlight":{"on":"plotly_click","persistent":false,"dynamic":false,"selectize":false,"opacityDim":0.2,"selected":{"opacity":1},"debounce":0},"shinyEvents":["plotly_hover","plotly_click","plotly_selected","plotly_relayout","plotly_brushed","plotly_brushing","plotly_clickannotation","plotly_doubleclick","plotly_deselect","plotly_afterplot","plotly_sunburstclick"],"base_url":"https://plot.ly"},"evals":[],"jsHooks":[]}</script>
<p>From the manual calculation above, the algorithm will compare the density from one point to its nearest point. If the density is similar and the lof score is a ratio, the result will be 1. If the density of the neighbour is lesser than the density of the point, it indicates that that point is still inside the cluster; hence it is not an outlier. The result of the lof score itself will be less than 1. If the density of the nearest neighbour of the point is higher than then the density of the point itself, the point is likely to be isolated, and it is an outlier. The lof score will be greater than 1.</p>
</div>
</div>
<div id="local-outlier-factor-application-in-industry-example" class="section level2">
<h2>Local Outlier Factor Application in Industry: Example</h2>
<p>The illustration of the local outlier factor above can be used to detect outliers from a dataset. Furthermore, the algorithm can be used to detect anomaly conditions. Many companies deal with anomaly data, and anomaly detection systems are in high demand. The domain business for each industry is needed to gain a deep understanding of the anomaly condition. For example, in the manufacturing industry, anomaly detection is needed as quality control. In the bank industry, an anomaly detection system is needed to detect genuine and fraudulent transactions.</p>
</div>
</div>
<div id="local-outlier-factor-application-in-fraud-detection" class="section level1">
<h1>Local Outlier Factor Application in Fraud Detection</h1>
<p>The use of KNN distance here is excellent to detect a global anomaly. To see the application of the Local Outlier Factor Algorithm, we will use a dataset consist of many points. Besides using outlier detection, we can also use the method to detect anomalies in a dataset. Here, we will see the application of the method of fraud detection in the financial dataset.</p>
<p>This dataset is a synthetic dataset generated using the simulator called PaySim. The dataset contains financial transactions with fraud observations. PaySim simulates mobile money transactions based on a sample of genuine transactions extracted from one month of financial logs from a mobile money service implemented in an African country. The original logs were provided by a multinational company, the provider of the mobile financial service, which is currently running in more than 14 countries worldwide. The source of the data can be found <a href="https://www.kaggle.com/ealaxi/paysim1">here</a></p>
<pre class="r"><code>fraud &lt;- read.csv(&#39;data_input/lof/fraud.csv&#39;)

str(fraud)</code></pre>
<pre><code>## &#39;data.frame&#39;:    6362620 obs. of  11 variables:
##  $ step          : int  1 1 1 1 1 1 1 1 1 1 ...
##  $ type          : chr  &quot;PAYMENT&quot; &quot;PAYMENT&quot; &quot;TRANSFER&quot; &quot;CASH_OUT&quot; ...
##  $ amount        : num  9840 1864 181 181 11668 ...
##  $ nameOrig      : chr  &quot;C1231006815&quot; &quot;C1666544295&quot; &quot;C1305486145&quot; &quot;C840083671&quot; ...
##  $ oldbalanceOrg : num  170136 21249 181 181 41554 ...
##  $ newbalanceOrig: num  160296 19385 0 0 29886 ...
##  $ nameDest      : chr  &quot;M1979787155&quot; &quot;M2044282225&quot; &quot;C553264065&quot; &quot;C38997010&quot; ...
##  $ oldbalanceDest: num  0 0 0 21182 0 ...
##  $ newbalanceDest: num  0 0 0 0 0 ...
##  $ isFraud       : int  0 0 1 1 0 0 0 0 0 0 ...
##  $ isFlaggedFraud: int  0 0 0 0 0 0 0 0 0 0 ...</code></pre>
<p>Each fitures of the data is described as follows:</p>
<ul>
<li><code>step</code> - maps a unit of time in the real world. In this case 1 step is 1 hour of time. Total steps 744 (30 days simulation).</li>
<li><code>type</code> - CASH-IN, CASH-OUT, DEBIT, PAYMENT and TRANSFER.</li>
<li><code>amount</code> - amount of the transaction in local currency.</li>
<li><code>nameOrig</code>- customer who started the transaction</li>
<li><code>oldbalanceOrg</code> - initial balance before the transaction</li>
<li><code>newbalanceOrig</code> - new balance recipient after the transaction.</li>
<li><code>nameDest</code> - customer who is the recipient of the transaction</li>
<li><code>oldbalanceDest</code> - initial balance recipient before the transaction.</li>
<li><code>newbalanceDest</code> - new balance recipient after the transaction.</li>
<li><code>isFraud</code> - This is the transactions made by the fraudulent agents inside the simulation.</li>
<li><code>isFlaggedFraud</code> - The business model aims to control massive transfers from one account to another and flags illegal attempts.</li>
</ul>
<p>Before we proceed with the algorithm, a few steps of dataset cleaning needs to be done. First, we need to convert the incorrect type of variables. Here, the variable of type needs to be converted into a factor. We also need to drop the nameOrig and nameDest variables since they contain many unique values.</p>
<pre class="r"><code>fraud_clean &lt;- fraud %&gt;% 
  mutate(type = as.factor(type),
         isFraud = as.factor(isFraud)) %&gt;% 
  select(-c(nameOrig, nameDest))</code></pre>
<p>We can see the data once again</p>
<pre class="r"><code>str(fraud_clean)</code></pre>
<pre><code>## &#39;data.frame&#39;:    6362620 obs. of  9 variables:
##  $ step          : int  1 1 1 1 1 1 1 1 1 1 ...
##  $ type          : Factor w/ 5 levels &quot;CASH_IN&quot;,&quot;CASH_OUT&quot;,..: 4 4 5 2 4 4 4 4 4 3 ...
##  $ amount        : num  9840 1864 181 181 11668 ...
##  $ oldbalanceOrg : num  170136 21249 181 181 41554 ...
##  $ newbalanceOrig: num  160296 19385 0 0 29886 ...
##  $ oldbalanceDest: num  0 0 0 21182 0 ...
##  $ newbalanceDest: num  0 0 0 0 0 ...
##  $ isFraud       : Factor w/ 2 levels &quot;0&quot;,&quot;1&quot;: 1 1 2 2 1 1 1 1 1 1 ...
##  $ isFlaggedFraud: int  0 0 0 0 0 0 0 0 0 0 ...</code></pre>
<p>The type of each variable is correct and we can proceed to do next analysis.</p>
<pre class="r"><code>library(treemap)
transaction &lt;- c(&quot;fraud&quot;,&quot;genuine&quot;)
value &lt;- c(sum(fraud_clean$isFraud == 1), sum(fraud_clean$isFraud == 0))
percentage &lt;- c(sum(fraud_clean$isFraud == 1)/length(fraud_clean$isFraud)*100,
                sum(fraud_clean$isFraud == 0)/length(fraud_clean$isFraud)*100)
prop &lt;- data.frame(transaction,value,percentage)
prop</code></pre>
<pre><code>##   transaction   value percentage
## 1       fraud    8213   0.129082
## 2     genuine 6354407  99.870918</code></pre>
<p>The proportion of genuine transactions is superior compared to the fraud one. The proportion of fraud transactions is less than 1% of overal transactions.</p>
<pre class="r"><code>total_trans &lt;- fraud_clean %&gt;% 
  group_by(type) %&gt;% 
  count(type) %&gt;% 
  arrange(desc(n))</code></pre>
<pre class="r"><code>library(highcharter)

hctreemap(trm, allowDrillToNode = TRUE) %&gt;% 
   hc_title(text = &quot;Number of Transactions Based on Transaction Type&quot;) %&gt;%
  hc_exporting(enabled = TRUE)</code></pre>
<div id="htmlwidget-3" style="width:100%;height:500px;" class="highchart html-widget"></div>
<script type="application/json" data-for="htmlwidget-3">{"x":{"hc_opts":{"chart":{"reflow":true},"title":{"text":"Number of Transactions Based on Transaction Type"},"yAxis":{"title":{"text":null}},"credits":{"enabled":false},"exporting":{"enabled":true},"boost":{"enabled":false},"plotOptions":{"series":{"label":{"enabled":false},"turboThreshold":0},"treemap":{"layoutAlgorithm":"squarified"}},"series":[{"data":[{"name":"CASH_IN","value":1399284,"valuecolor":1,"level":1,"color":"#FFF7F3","id":"cash_in"},{"name":"CASH_OUT","value":2237500,"valuecolor":1,"level":1,"color":"#FDE0DD","id":"cash_out"},{"name":"DEBIT","value":41432,"valuecolor":1,"level":1,"color":"#FCC5C0","id":"debit"},{"name":"PAYMENT","value":2151495,"valuecolor":1,"level":1,"color":"#FA9FB5","id":"payment"},{"name":"TRANSFER","value":532909,"valuecolor":1,"level":1,"color":"#F768A1","id":"transfer"}],"type":"treemap","allowDrillToNode":true}]},"theme":{"chart":{"backgroundColor":"transparent"},"colors":["#7cb5ec","#434348","#90ed7d","#f7a35c","#8085e9","#f15c80","#e4d354","#2b908f","#f45b5b","#91e8e1"]},"conf_opts":{"global":{"Date":null,"VMLRadialGradientURL":"http =//code.highcharts.com/list(version)/gfx/vml-radial-gradient.png","canvasToolsURL":"http =//code.highcharts.com/list(version)/modules/canvas-tools.js","getTimezoneOffset":null,"timezoneOffset":0,"useUTC":true},"lang":{"contextButtonTitle":"Chart context menu","decimalPoint":".","downloadJPEG":"Download JPEG image","downloadPDF":"Download PDF document","downloadPNG":"Download PNG image","downloadSVG":"Download SVG vector image","drillUpText":"Back to {series.name}","invalidDate":null,"loading":"Loading...","months":["January","February","March","April","May","June","July","August","September","October","November","December"],"noData":"No data to display","numericSymbols":["k","M","G","T","P","E"],"printChart":"Print chart","resetZoom":"Reset zoom","resetZoomTitle":"Reset zoom level 1:1","shortMonths":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"thousandsSep":" ","weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"]}},"type":"chart","fonts":[],"debug":false},"evals":[],"jsHooks":[]}</script>
<p>The majority of the transactions came from Cash out, with over two million transactions. The following transactions are Payment, Cash in and Debit.</p>
<p>We can also visualize the distribution of fraud transactions based on each type.</p>
<pre class="r"><code>total_fraud &lt;- fraud_clean %&gt;% 
  filter(isFraud == 1) %&gt;% 
  select(type) %&gt;% 
  group_by(type) %&gt;% 
  count(type) %&gt;% 
  arrange(desc(n))</code></pre>
<pre class="r"><code>hctreemap(trmf, allowDrillToNode = TRUE) %&gt;% 
   hc_title(text = &quot;Fraud Transactions Based on Transaction Type&quot;) %&gt;%
  hc_exporting(enabled = TRUE)</code></pre>
<pre><code>## Warning: &#39;hctreemap&#39; is deprecated.
## Use &#39;data_to_hierarchical&#39; instead.
## See help(&quot;Deprecated&quot;)</code></pre>
<div id="htmlwidget-4" style="width:100%;height:500px;" class="highchart html-widget"></div>
<script type="application/json" data-for="htmlwidget-4">{"x":{"hc_opts":{"chart":{"reflow":true},"title":{"text":"Fraud Transactions Based on Transaction Type"},"yAxis":{"title":{"text":null}},"credits":{"enabled":false},"exporting":{"enabled":true},"boost":{"enabled":false},"plotOptions":{"series":{"label":{"enabled":false},"turboThreshold":0},"treemap":{"layoutAlgorithm":"squarified"}},"series":[{"data":[{"name":"CASH_OUT","value":4116,"valuecolor":1,"level":1,"color":"#ECE2F0","id":"cash_out"},{"name":"TRANSFER","value":4097,"valuecolor":1,"level":1,"color":"#67A9CF","id":"transfer"}],"type":"treemap","allowDrillToNode":true}]},"theme":{"chart":{"backgroundColor":"transparent"},"colors":["#7cb5ec","#434348","#90ed7d","#f7a35c","#8085e9","#f15c80","#e4d354","#2b908f","#f45b5b","#91e8e1"]},"conf_opts":{"global":{"Date":null,"VMLRadialGradientURL":"http =//code.highcharts.com/list(version)/gfx/vml-radial-gradient.png","canvasToolsURL":"http =//code.highcharts.com/list(version)/modules/canvas-tools.js","getTimezoneOffset":null,"timezoneOffset":0,"useUTC":true},"lang":{"contextButtonTitle":"Chart context menu","decimalPoint":".","downloadJPEG":"Download JPEG image","downloadPDF":"Download PDF document","downloadPNG":"Download PNG image","downloadSVG":"Download SVG vector image","drillUpText":"Back to {series.name}","invalidDate":null,"loading":"Loading...","months":["January","February","March","April","May","June","July","August","September","October","November","December"],"noData":"No data to display","numericSymbols":["k","M","G","T","P","E"],"printChart":"Print chart","resetZoom":"Reset zoom","resetZoomTitle":"Reset zoom level 1:1","shortMonths":["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"thousandsSep":" ","weekdays":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"]}},"type":"chart","fonts":[],"debug":false},"evals":[],"jsHooks":[]}</script>
<p>Here, we see that the fraud transactions only come from these two types of variables. The fraud transactions come from Cash_out and the transfer variable.</p>
<p>We will shrink the data to focus only on the fraud condition with these two types of transactions.</p>
<pre class="r"><code>fraud_clean_real &lt;- fraud_clean %&gt;% 
  filter(type == &quot;CASH_OUT&quot; | type == &quot;TRANSFER&quot;)

str(fraud_clean_real)</code></pre>
<pre><code>## &#39;data.frame&#39;:    2770409 obs. of  9 variables:
##  $ step          : int  1 1 1 1 1 1 1 1 1 1 ...
##  $ type          : Factor w/ 5 levels &quot;CASH_IN&quot;,&quot;CASH_OUT&quot;,..: 5 2 2 5 5 2 2 2 2 5 ...
##  $ amount        : num  181 181 229134 215310 311686 ...
##  $ oldbalanceOrg : num  181 181 15325 705 10835 ...
##  $ newbalanceOrig: num  0 0 0 0 0 ...
##  $ oldbalanceDest: num  0 21182 5083 22425 6267 ...
##  $ newbalanceDest: num  0 0 51513 0 2719173 ...
##  $ isFraud       : Factor w/ 2 levels &quot;0&quot;,&quot;1&quot;: 2 2 1 1 1 1 1 1 1 1 ...
##  $ isFlaggedFraud: int  0 0 0 0 0 0 0 0 0 0 ...</code></pre>
<pre class="r"><code>dim(fraud_clean_real)</code></pre>
<pre><code>## [1] 2770409       9</code></pre>
<pre class="r"><code>prop.table(table(fraud_clean_real$isFraud))*100</code></pre>
<pre><code>## 
##          0          1 
## 99.7035456  0.2964544</code></pre>
<p>The number of fraud transactions is 0.3% after the second cleaning. This is much lower compared to the genuine transactions by 99.7%. In the real world, we often face the situation of an imbalanced dataset because the fraudulent transaction is often relatively small than the actual transactions.</p>
<p>In reality, the dataset obtained from one experiment or situation does not have a labelled variable. The local outlier factor algorithm will assess the situation to detect which observation is likely to be an outlier compared to other observations. Before we do the algorithm to the data, we need to scale the numerical variable of each data. Scaling is vital since the calculation will be based on distance, and the distance should be calculated at the same level. We also need to drop the categorical variable.</p>
<pre class="r"><code>fraud_scale &lt;- fraud_clean_real %&gt;% select(-c(isFraud, isFlaggedFraud, type))

fraud_scale &lt;- as.data.frame(scale(fraud_scale))

head(fraud_scale)</code></pre>
<pre><code>##        step       amount oldbalanceOrg newbalanceOrig oldbalanceDest
## 1 -1.701804 -0.357466589   -0.18884733     -0.1063887     -0.4031548
## 2 -1.701804 -0.357466589   -0.18884733     -0.1063887     -0.3981420
## 3 -1.701804 -0.099575615   -0.12859072     -0.1063887     -0.4019519
## 4 -1.701804 -0.115146465   -0.18676238     -0.1063887     -0.3978478
## 5 -1.701804 -0.006589681   -0.14645603     -0.1063887     -0.4016717
## 6 -1.701804 -0.233300117   -0.08275205     -0.1063887     -0.3348087
##   newbalanceDest
## 1     -0.4382593
## 2     -0.4382593
## 3     -0.4272451
## 4     -0.4382593
## 5      0.1431345
## 6     -0.4377429</code></pre>
<p>After we scale the data frame, we can use the lof function to calculate the lof score. Choosing the k value will determine the number of a neighbor of each data for the calculations. If choosing a small number of k will result in an algorithm that is sensitive to noise. If we choose a large amount of K, the algorithm will not recognize local anomalies. For this article, we will try using k = 40. Another approach of K can be used for the calculations.</p>
<pre class="r"><code>fraud_lof &lt;- lof(fraud_scale, k = 40)</code></pre>
<p>We then store the result to the original cleaned dataset for visualization.</p>
<pre class="r"><code>fraud_clean_real$lof &lt;- fraud_lof

head(fraud_clean_real)</code></pre>
<pre><code>##   step     type   amount oldbalanceOrg newbalanceOrig oldbalanceDest
## 1    1 TRANSFER    181.0        181.00              0              0
## 2    1 CASH_OUT    181.0        181.00              0          21182
## 3    1 CASH_OUT 229133.9      15325.00              0           5083
## 4    1 TRANSFER 215310.3        705.00              0          22425
## 5    1 TRANSFER 311685.9      10835.00              0           6267
## 6    1 CASH_OUT 110414.7      26845.41              0         288800
##   newbalanceDest isFraud isFlaggedFraud      lof
## 1           0.00       1              0 1.062760
## 2           0.00       1              0 1.048131
## 3       51513.44       0              0 1.854769
## 4           0.00       0              0 2.050010
## 5     2719172.89       0              0 1.174495
## 6        2415.16       0              0 1.685906</code></pre>
<p>To gain more understanding of the data, we will see the distribution between fraud and genuine transactions. Since the dataset consists of more than two variables, we can use PCA and use the first two dimensions of the PCA.</p>
<pre class="r"><code>library(FactoMineR)
library(factoextra)

fraud_pca &lt;- PCA(fraud_scale, scale.unit = F, ncp = 6, graph = F)

summary(fraud_pca)</code></pre>
<pre><code>## 
## Call:
## PCA(X = fraud_scale, scale.unit = F, ncp = 6, graph = F) 
## 
## 
## Eigenvalues
##                        Dim.1   Dim.2   Dim.3   Dim.4   Dim.5   Dim.6
## Variance               2.238   1.788   0.997   0.756   0.213   0.008
## % of var.             37.301  29.804  16.624  12.595   3.544   0.132
## Cumulative % of var.  37.301  67.106  83.730  96.324  99.868 100.000
## 
## Individuals (the 10 first)
##                    Dist    Dim.1    ctr   cos2    Dim.2    ctr   cos2    Dim.3
## 1              |  1.851 | -0.785  0.000  0.180 | -0.182  0.000  0.010 | -1.666
## 2              |  1.850 | -0.782  0.000  0.179 | -0.182  0.000  0.010 | -1.666
## 3              |  1.811 | -0.666  0.000  0.135 | -0.121  0.000  0.004 | -1.660
## 4              |  1.818 | -0.679  0.000  0.139 | -0.163  0.000  0.008 | -1.661
## 5              |  1.764 | -0.252  0.000  0.020 | -0.152  0.000  0.007 | -1.684
## 6              |  1.809 | -0.686  0.000  0.144 | -0.102  0.000  0.003 | -1.665
## 7              |  1.832 | -0.738  0.000  0.162 | -0.174  0.000  0.009 | -1.666
## 8              |  2.004 |  0.220  0.000  0.012 | -0.252  0.000  0.016 | -1.737
## 9              |  1.838 | -0.767  0.000  0.174 | -0.124  0.000  0.005 | -1.665
## 10             |  1.830 | -0.742  0.000  0.164 |  0.121  0.000  0.004 | -1.662
##                   ctr   cos2  
## 1               0.000  0.810 |
## 2               0.000  0.811 |
## 3               0.000  0.841 |
## 4               0.000  0.834 |
## 5               0.000  0.912 |
## 6               0.000  0.847 |
## 7               0.000  0.827 |
## 8               0.000  0.751 |
## 9               0.000  0.820 |
## 10              0.000  0.825 |
## 
## Variables
##                   Dim.1    ctr   cos2    Dim.2    ctr   cos2    Dim.3    ctr
## step           |  0.077  0.265  0.006 | -0.008  0.004  0.000 |  0.996 99.454
## amount         |  0.633 17.879  0.400 |  0.099  0.549  0.010 |  0.023  0.052
## oldbalanceOrg  |  0.051  0.114  0.003 |  0.944 49.815  0.891 |  0.012  0.015
## newbalanceOrig |  0.019  0.016  0.000 |  0.937 49.127  0.879 | -0.013  0.016
## oldbalanceDest |  0.929 38.531  0.862 | -0.074  0.308  0.006 | -0.050  0.252
## newbalanceDest |  0.983 43.195  0.967 | -0.060  0.199  0.004 | -0.046  0.210
##                  cos2  
## step            0.992 |
## amount          0.001 |
## oldbalanceOrg   0.000 |
## newbalanceOrig  0.000 |
## oldbalanceDest  0.003 |
## newbalanceDest  0.002 |</code></pre>
<pre class="r"><code>fviz_eig(fraud_pca, ncp = 6, addlabels = T, main = &quot;Variance explained by each dimensions&quot;)</code></pre>
<p><img src="/blog/Local%20Outlier%20Factor%20revised%20algo_files/figure-html/unnamed-chunk-46-1.png" width="672" /></p>
<p>The result from PCA above shows that if we use the first two dimensions of the data, we still retain 67% variance from the original data. The first two dimensions along with the LOF score and fraud label is obtained and stored in the new data frame.</p>
<pre class="r"><code>fraud_a &lt;- data.frame(fraud_pca$ind$coord[,1:3])
fraud_b &lt;- cbind(fraud_a, fraud = fraud_clean_real$isFraud, lof_score = fraud_clean_real$lof)

fraud_lof_visual &lt;- ggplot(fraud_b, aes(x=Dim.1 ,y=Dim.2, color=fraud)) + 
    geom_point(aes(size=lof_score)) +
  ggtitle(&quot;LOF Score Distribution&quot;)+
    theme_ipsum()

fraud_lof_visual</code></pre>
<p><img src="/blog/Local%20Outlier%20Factor%20revised%20algo_files/figure-html/unnamed-chunk-47-1.png" width="672" /></p>
<p>From the visualization above, we can see that genuine and fraudulent transactions have different patterns. The higher the lof score it has, the dot is bolder and more prominent.</p>
<p>The rule of thumb of the lof score says that if the LOF score is more than 1, it is likely to be an outlier. Somehow, a threshold can be adjusted with the distribution of the data. Let’s see the statistics of the LOF score first.</p>
<pre class="r"><code>summary(fraud_b)</code></pre>
<pre><code>##      Dim.1               Dim.2              Dim.3          fraud      
##  Min.   : -0.78483   Min.   : -8.2534   Min.   :-6.76640   0:2762196  
##  1st Qu.: -0.53961   1st Qu.: -0.2033   1st Qu.:-0.61967   1:   8213  
##  Median : -0.37178   Median : -0.1802   Median :-0.02065              
##  Mean   :  0.00000   Mean   :  0.0000   Mean   : 0.00000              
##  3rd Qu.:  0.03398   3rd Qu.: -0.0909   3rd Qu.: 0.65432              
##  Max.   :111.61041   Max.   :397.7378   Max.   : 4.20721              
##    lof_score     
##  Min.   :0.9414  
##  1st Qu.:0.9970  
##  Median :1.0156  
##  Mean   :1.0605  
##  3rd Qu.:1.0587  
##  Max.   :7.2294</code></pre>
<p>The LOF score has a max score of more than 7. If we include a point that falls far from the distribution, it will be hard to visualize. Hence, we will set the LOF score until 1.75 and see the distribution of the LOF score.</p>
<pre class="r"><code>fraud_b %&gt;%
  filter(lof_score &lt;= 1.75) %&gt;% 
  ggplot( aes(x=lof_score)) +
    geom_density( color=&quot;#e9ecef&quot;, fill = &quot;#c90076&quot;, alpha=0.7) +
    scale_fill_manual(values=&quot;#8fce00&quot;) +
    xlab(&quot;LOF Score&quot;)+
  ggtitle(&quot;LOF Score Distribution&quot;)+
    theme_ipsum() +
    labs(fill=&quot;&quot;)</code></pre>
<p><img src="/blog/Local%20Outlier%20Factor%20revised%20algo_files/figure-html/unnamed-chunk-49-1.png" width="672" /></p>
<p>We see above, the LOF score have many points with the score more than 1. To classify a point as an outlier or not, we can set the threshold higher.</p>
<p>One method to determine threshold is calculating the quantile point. Here, we will set threshold 90% as the normal points, while the last 10% is considered as outlier. The threshold proportion can be adjusted depend on the business case. If user wish to more cautios with the LOF score, user can set the threshold higher.</p>
<pre class="r"><code>quantile(fraud_b$lof_score, probs = c(0, 0.9))</code></pre>
<pre><code>##        0%       90% 
## 0.9414236 1.1599704</code></pre>
<p>The 90% proportion of the LOF score falls under below 1.1599704. We will use this threshold to determine if a point falls under the threshold; we categorize that point as an outlier.</p>
<pre class="r"><code>fraud_b &lt;- fraud_b %&gt;% 
  mutate(outlier = ifelse(lof_score &gt; 1.1599704, 1, 0))</code></pre>
<p>We can once again visualize the distribution of the outlier for all observations.</p>
<pre class="r"><code>fraud_lof_visual_b &lt;- ggplot(fraud_b, aes(x=Dim.1 ,y=Dim.2, color=outlier)) + 
    geom_point() +
  ggtitle(&quot;LOF Score Distribution&quot;)+
    theme_ipsum()

fraud_lof_visual_b</code></pre>
<p><img src="/blog/Local%20Outlier%20Factor%20revised%20algo_files/figure-html/unnamed-chunk-52-1.png" width="672" /></p>
<p>The visualization above shows us that there are outliers both in fraud or actual data. The user needs to investigate this observation and evaluate it in the system. By using the LOF algorithm, users can prevent unwanted observation from transactions. Preventive action is a must condition dealing with the condition for fraudulent transactions. The high lof score in genuine transactions should be interpreted with more domain background of the financial case. For example, there might be the high amount of transactions during that time, and it was real transaction by a person.</p>
</div>
<div id="important-notes-about-local-outlier-factor" class="section level1">
<h1>Important Notes about Local Outlier Factor</h1>
<p>Many cases involved outlier or anomaly detection has not provided with labeled variable. If the dataset has provided with the labeled target variable, it can assess the detection quality. Local Outlier Factor will assess the unusual score without knowing the actual condition of the observation; for this case, it doesn’t know the actual value of a dataset is fraud/outlier or not. The reality of a dataset often provides us with a condition of whether a data point is an outlier or not. The local outlier factor is unsupervised machine learning that often does not involved labeled variables. The score produced by the algorithm can be an additional point of view in a supervised machine learning algorithm.</p>
<p>Some important notes about predicting outlier or anomaly conditions are too few cases in detecting diseases or the rapidly changing behavior in fraud transactions. If we face a situation like this, we can’t solely use unsupervised machine learning algorithms to detect. Some robust technique needs to be assessed to acquire better result.</p>
<p>The local outlier factor will produce a number in a ratio interval. If the score is more than 1, it means the density of the neighbors is higher. The interpretation of a ratio can be adjusted based on the business recommendation of a user rather than solely interpret lof &gt; 1 as an outlier. If the user wants to be more selective in detecting outlier observation, the user can increase the threshold of the lof score based on the domain business.</p>
</div>
<div id="conclusion" class="section level1">
<h1>Conclusion</h1>
<p>Outlier is a condition where an observation in a dataset is different than the rest of the data. To detect if an observation is an outlier or not, several methods can be used. Grubbs’ test is a good tool for outlier detection, but it will not work in multivariate data, and a natural problem dataset often deals with a dataset with many variables. We can use the local outlier factor to handle the situation where we can use outlier detection in multivariate data. The algorithm will use a comparison of the density of observation to the density of K-nearest neighbor observation. The LOF needs K as the attribute to calculate its nearest neighbor observations, and by simulating different K, the algorithm will produce different lof scores. More K value is used, the more stable algorithm can detect an outlier. Although the algorithm is used to detect outlier observation, it can be used to detect anomaly situations. The result of fraud detection produces LOF with 86% precision. Although LOF can be used to assess supervised machine learning problems, note that several business case backgrounds need to be noticed, such as the proportion of imbalanced datasets.</p>
</div>
<div id="further-recommendation" class="section level1">
<h1>Further Recommendation</h1>
<p>Different K produces different quality of semi-supervised algorithm of LOF. To gain more understanding of the chosen K, the user can use many points of K and see if the algorithm will converge in specific K. The LOF contribute with numerical variable since it relies on the distance, to assess the situation with categorical features, different distance metrics may be used for this problem.</p>
</div>
<div id="reference" class="section level1">
<h1>Reference</h1>
<p>Breunig, M. M., Kriegel, H. P., Ng, R. T., and Sander, J. (2000). LOF: identifying density-based local outliers. In ACM sigmod record (Vol. 29, №2, pp. 93–104). ACM.</p>
<p><a href="https://en.wikipedia.org/wiki/Local_outlier_factor" class="uri">https://en.wikipedia.org/wiki/Local_outlier_factor</a></p>
<p><a href="https://towardsdatascience.com/local-outlier-factor-lof-algorithm-for-outlier-identification-8efb887d9843" class="uri">https://towardsdatascience.com/local-outlier-factor-lof-algorithm-for-outlier-identification-8efb887d9843</a></p>
</div>
